# 演算子

多くの演算子は学校で学んできたので知られています。加算 `+`, 乗算 `*`, 減算 `-` などです。

このチャプターでは、学校の算数でカバーされない側面に集中します。

[cut]

## 用語： "単項演算子"、 "バイナリ"、 "オペランド" [#terms-unary-binary-operand]

次に進む前に、一般的な用語を理解しましょう。

- *オペランド* -- は演算子が適用されるものです。たとえば、 乗算 `5 * 2` では、2つのオペランドがあります: 左のオペランドは `5`, 右のオペランドは `2` です。時々、人々は "オペランド" のかわりに "引数" といいます。
- 演算子が単一のオペランドをもつ場合は *単項演算子* です。たとえば、単行否定 `"-"` は数値の符号を反転します:

    ```js run
    let x = 1;

    *!*
    x = -x;
    */!*
    alert( x ); // -1, 単項否定が適用されました
    ```
- 演算子が2つのオペランドを持つ場合は *バイナリ* です。同じマイナスもバイナリ形式で同様に存在します:

    ```js run no-beautify
    let x = 1, y = 3;
    alert( y - x ); // 2, バイナリマイナスは値を減算します
    ```

    正式には、ここでは2つの異なった演算子について話しています。: 単行否定(1つのオペランド, 符号の反転)　とバイナリ減算(2つのオペランド、減算)

## 文字列の連結、バイナリ + [#strings-concatenation-binary]

さて、学校の算術以外の JavaScript 演算子の特別な機能を見ていきましょう。

通常、プラス演算子 `+` は数値の合計です。

しかし、もしもバイナリ `+` が文字列に適用された場合、それはそれらのマージ（連結）です。:

```js
let s = "my" + "string";
alert(s); // mystring
```

もしもいずれかのオペランドが文字列の場合、他のオペランドも文字列に変換されることに注意してください。

例:

```js run
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
```

見てください、最初のオペランドが文字列か、2つ目のものがそうかは関係ありません。このルールはシンプルです:もしもどちらかのオペランドが文字列の場合、同様に他の一方も文字列に変換します。

文字列連結や変換はバイナリプラス `"+"` の特別な機能です。他の算術演算子は数値でのみ動作します。それらはいつもオペランドを数値に変換します。

たとえば、減算と除算です:

```js run
alert( 2 - '1' ); // 1
alert( '6' / '2' ); // 3
```

## 数値変換 単項 + [#numeric-conversion-unary]

プラス `+` は2つの形で存在します。上で使ったようなバイナリ形式と単項形式です。

単項プラス、もしくは言い換えると単一の値に適用されるプラス演算子 `+` は、数値に対しては何もしません。しかし、オペランドが数値でない場合は数値に変換します。

例:

```js run
// 数値には何の影響もありません
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

*!*
// 非数値を変換
alert( +true ); // 1
alert( +"" );   // 0
*/!*
```

それは実際には、 `Number(...)` と同じですが、より短い表現です。

文字列から数値に変換する必要なケースは多いです。HTMLのフォームフィールドから値を取得する場合、それらは通常文字列です。

今、それらの合計が欲しい場合はどうなるでしょう？

バリナリプラスはそれらを文字列として追加します。:

```js run
let apples = "2";
let oranges = "3";

alert( apples + oranges ); // "23", バイナリプラスは文字列を連結します
```

それらを文字列として扱いたい場合、変換してそれらを合計することが出来ます:

```js run
let apples = "2";
let oranges = "3";

*!*
// バイナリプラスの前に両方の値が数値に変換されます
alert( +apples + +oranges ); // 5
*/!*

// 長いバリアント
// alert( Number(apples) + Number(oranges) ); // 5
```

数学者の立場からは、余計なプラスは奇妙に見えるかもしれません。しかし、プログラマの立場からは特殊なことではありません: 単項プラスが最初に適用され、文字列から数値に変換されます。次にバイナリプラスはそれらを合計します。

なぜバイナリプラスの前に単項プラスが値に適用されるのでしょうか？それは、単項プラスの *優先順位が高いため* です。

## 演算子の優先順位 [#operators-precedence]

式が1つ以上の演算子をもつ場合、実行順はそれらの *優先順位* により定義されています。言い換えると、演算子の間には暗黙の優先順があります。

学校から、私たちはみんな、式 `1 + 2 * 2` での乗算は加算の前に計算されるべきであることを知っています。それがまさに優先順位です。乗算は加算より *より高い優先順位* と言われています。

丸括弧はどの優先順位もオーバーライドするので、実行順序が不満な場合は丸括弧使うことができます、このように: `(1 + 2) * 2`。

JavaScriptでは多くの演算子があります。どの演算子も対応する優先順位を持っています。より大きな値をもつ演算子は最初に実行されます。同じ優先順の場合、実行順は左から右になります。

[優先順位テーブル](https://developer.mozilla.org/en/JavaScript/Reference/operators/operator_precedence)の抜粋(これを覚えておく必要はありませんが、単項演算子は対応するバイナリ演算子よりも優先順位が高いことに留意してください):


| 優先順位 | 名前 | 符号 |
|------------|------|------|
| ... | ... | ... |
| 16 | 単項プラス | `+` |
| 16 | 単項否定 | `-` |
| 14 | 乗算 | `*` |
| 14 | 除算 | `/` |
| 13 | 加算 | `+` |
| 13 | 減算 | `-` |
| ... | ... | ... |
| 3 | 代入 | `=` |
| ... | ... | ... |

ご覧の通り、 "単項プラス" は `16` の優先順位を持っており、それは "加算" の `13` よりも大きいです(バイナリプラス)。なので、式 `"+apples + +oranges"` において、単項プラスは最初に動作し、次に加算になります。

## 代入 [#assignment]

代入 `=` もまた演算子であることに注意しましょう。 `3`というとても低い値として優先順位テーブルにリストされています。

そういうわけで、`x = 2 * 2 + 1` のように変数を代入するとき、計算が最初に行われ、その後 `=` が評価され、 `x` に結果が格納されます。

```js
let x = 2 * 2 + 1;

alert( x ); // 5
```

代入をチェーンすることもできます:

```js run
let a, b, c;

*!*
a = b = c = 2 + 2;
*/!*

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
```

チェーンされた代入は右から左へ評価されます。最初に最も右の式 `2 + 2` が評価され、次に左の変数に代入されます。: `c`, `b` と `a`です。
最後に、全ての変数は単一の値で共有されます。

````smart header="代入演算子 `\"=\"` は値を返します"
演算子は常に値を返します。それは加算 `+` または 乗算 `*` のようにほとんどの場合明らかです。しかし代入演算子もそのルールに従います。

`x = value` の呼び出しは `value` を `x` に書き込み、 *それを返却します*

これは、より複雑な式の一部として代入を使ったデモです:

```js run
let a = 1;
let b = 2;

*!*
let c = 3 - (a = b + 1);
*/!*

alert( a ); // 3
alert( c ); // 0
```

上の例は、`(a = b + 1)` の結果は `a` に代入された値です(それは `3` です)。次にそれは `3` から減算するために使われます。

面白いコードですよね？サードパーティーのライブラリで見かけることがあるので、それがどのように動作するかは理解しておくのがよいでしょう。
しかし、このようなものは書くべきではありません。このようなトリックは明らかにコードの可読性を損ないます。
````

## 剰余 % [#remainder]

剰余演算子 `%` はその見た目にもかかわらず、パーセントと関係はありません。

`a % b` の結果は、`b` による `a` の割り数割り算の余りです。

例:

```js run
alert( 5 % 2 ); // 1は5を2で割った余りです
alert( 8 % 3 ); // 2は8を3で割った余りです
alert( 6 % 3 ); // 0は6を3で割った余りです
```

## べき乗 ** [#exponentiation]

べき乗演算子 `**` は最近言語に追加されています。

自然数 `b` において、`a ** b` の結果は、`b` の回数だけ自身により乗算された `a` です。  

例:

```js run
alert( 2 ** 2 ); // 4  (2 * 2)
alert( 2 ** 3 ); // 8  (2 * 2 * 2)
alert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2)
```

演算子は非整数値の `a` や　`b` でも同様に動作します。例えば:

```js run
alert( 4 ** (1/2) ); // 2 (1/2のべき乗は平方根と同じです、それは数学です)
alert( 8 ** (1/3) ); // 2 (1/3のべき乗は、立方根と同じです)
```

## インクリメント/デクリメント [#increment-decrement]

<!-- Can't use -- in title, because built-in parse turns it into – -->

数値を1ずつ増減することは、最も一般的な数値演算の1つです。

なので、そのための特別な演算子があります:

- **インクリメント** `++` 変数を1増加させる:

    ```js run no-beautify
    let counter = 2;
    counter++;      // counter = counter + 1 と同じですがより短いです
    alert( counter ); // 3
    ```
- **デクリメント** `--` 変数を1減少させる:

    ```js run no-beautify
    let counter = 2;
    counter--;      // counter = counter - 1 と同じですがより短いです
    alert( counter ); // 1
    ```

```warn
インクリメント/デクリメントは変数に対してのみ適用可能です。 それを `5++` のように値に対して使おうとすると、エラーになります。
```

演算子 `++` と `--` は変数の前後両方に配置することができます。

- 演算子が変数の後にある場合、それは "後置式" と呼ばれます: `counter++`。
- "前置式" は演算子が変数の前に来るときです: `++counter`。

結果はどちらも同じです: `counter` を `1` 増加します。

それらに違いはありますか？はい、しかし `++/--` の戻り値を使う場合、その値しかみることができません。

違いを明確にしましょう。ご存知の通り、全ての演算子は値を返します。ここではインクリメント/デクリメントも例外ではありません。前置式は新しい値を返す一方、後置式は古い値を返します(インクリメント/デクリメントの前)

違いを見るために、ここに例があります:

```js run
let counter = 1;
let a = ++counter; // (*)

alert(a); // *!*2*/!*
```

ここで `(*)` の行で前置呼び出し `++counter` は `counter` を増加させ、`2` という新しい値を返します。そのため、 `alert` は `2` を表示します。

後置式を使いましょう:

```js run
let counter = 1;
let a = counter++; // (*) ++counter を counter++ に変更

alert(a); // *!*1*/!*
```

`(*)` の行で、 *後置* 式 `counter++` は `counter` を増加しますが、 *古い* 値を返します(増加する前)。そのため、 `alert` は `1` を表示します。

要約する:

- もしもインクリメント/デクリメントの結果を使わない場合、どちらの形式を使う場合でも違いはありません。:

    ```js run
    let counter = 0;
    counter++;
    ++counter;
    alert( counter ); // 2, 上の行は同じことをします
    ```
- もしも値を増加に *加えて*、すぐに演算子の結果を使いたい場合は、前置式が必要になります:

    ```js run
    let counter = 0;
    alert( ++counter ); // 1
    ```
- もしも増加するが、以前の値を使いたい場合は後置式が必要です:

    ```js run
    let counter = 0;
    alert( counter++ ); // 0
    ```

````smart header="他の演算子の中でのインクリメント/デクリメント"
演算子 `++/--` は同様に式の中でも使うことができます。それらの優先順位は他の算術演算子よりも高いです。

例:

```js run
let counter = 1;
alert( 2 * ++counter ); // 4
```

比較:

```js run
let counter = 1;
alert( 2 * counter++ ); // 2, counter++ は "古い" 値を返すからです
```

技術的には許容されますが、このような記法は一般的に、コードの可読性を下げます。1行で複数のことを行う -- よいことではありません。

コードを読んでいる間、速い "縦の" 目視はこのような `counter++` を見逃しやすく、また変数の増加が明白ではありません。

"1行は1アクション" のスタイルが推奨されます:

```js run
let counter = 1;
alert( 2 * counter );
counter++;
```
````

## ビット演算子 [#bitwise-operators]

ビット演算子は引数を 32ビットの整数値として扱い、それらのバイナリ表現のレベルで処理します。

それらの演算子はJavaScript固有のものではありません。ほとんどのプログラミング言語でサポートされています。

演算子のリスト:

- AND ( `&` )
- OR ( `|` )
- XOR ( `^` )
- NOT ( `~` )
- LEFT SHIFT ( `<<` )
- RIGHT SHIFT ( `>>` )
- ZERO-FILL RIGHT SHIFT ( `>>>` )

これらの演算子はめったに使われません。それらを理解するためには、私たちは低レベルの数値表現について掘り下げるべきであり、それは現時点では最適ではないでしょう。特に、すぐには必要ないからです。もしもあなたが興味をもっている場合は、MDNの[ビット演算子 ](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators)の記事を読むことが出来ます。実際に必要になったときにそれをするのがより現実的でしょう。


## その場で変更する [#modify-in-place]

私たちは、しばしば変数に演算子を適用し、その中に新しい値を格納する必要があります。

例:

```js
let n = 2;
n = n + 5;
n = n * 2;
```

この表記法は演算子 `+=` と `*=` を使うことで短縮することができます:

```js run
let n = 2;
n += 5; // 今 n = 7 (n = n + 5 と同じ)
n *= 2; // 今 n = 14 (n = n * 2 と同じ)

alert( n ); // 14
```

短い "変更と代入" 演算子はすべての算術演算子とビット演算子で存在します。: `/=`, `-=` など。

このような演算子は通常の代入として同じ優先順位を持っています。そのため、ほとんどの他の計算の後に実行します:

```js run
let n = 2;

n *= 3 + 5;

alert( n ); // 16  (右のパートが最初に評価されるので、 n *= 8 と同じです)
```

## カンマ [#comma]

カンマ演算子 `','` は最もレアで普通ではない演算子の1つです。より短いコード書くために使われることがありますので、何が起こっているのか理解するために知っておく必要があります。

カンマ演算子を使うことで、いくつかの式カンマ `','` で分割して評価することを可能にします。それぞれが評価されますが、最後の1つの結果のみが返却されます。

例:

```js run
*!*
let a = (1 + 2, 3 + 4);
*/!*

alert( a ); // 7 (3 + 4 の結果)
```

ここで、最初の式 `1 + 2` は評価され、その結果はどこかへ捨てられます。次に `3 + 4` が評価され、結果として返却されます。

```smart header="カンマはとても優先順が低いです"
カンマ演算子はとても優先順位が低いことに注意してください。 `=` よりも低いため、上の例では丸括弧が重要です。

それらがない場合: `a = 1 + 2, 3 + 4` は `+` を最初に評価し、数値を `a = 3, 7` に加算します。次に代入演算子 `=` が `a = 3` を割り当てます。そして、カンマのあとの `7` は処理されず、無視されます。
```

なぜこのような最後の部分を除いてすべてを捨てる演算子が必要なのでしょうか？

より複雑な構造において、1行で複数のアクションを書くときに使用される場合があります。

例:

```js
// 1行に3つの演算子
for (*!*a = 1, b = 3, c = a * b*/!*; a < 10; a++) {
 ...
}
```

このようなトリックは多くのJavaScriptフレームワークで利用されているため、ここで言及しています。しかし通常それらはコードの可読性を改善しません。なので、そのように書く前によく考えるべきです。

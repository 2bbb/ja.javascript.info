# 論理演算子

JavaScriptには3つの論理演算子があります:  `||` (OR:論理和), `&&` (AND:論理積), `!` (NOT:否定)

それらは "論理" と呼ばれますが、ブール型だけでなく、どの型の値にも適用することができます。結果もまた任意の型になります。

詳細を見てみましょう:

[cut]

## || (OR) [#or]

"OR" 演算子は2つの縦のシンボルで表現されます:

```js
result = a || b;
```

古典的なプログラミングでは、論理和はブール値のみを操作することを意味していました。もしもその引数のいずれかが `true` の場合、それは `true` を返します。そうでなければ `false` を返します。

JavaScriptでは、演算子は少し難解で強力です。しかし最初にブール値で起こることを見てみましょう。

4つの可能な論理の組み合わせがあります:

```js run
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
```

私たちが見れるように、両方のオペランドが `false` の場合を除き、結果はいつも `true` です。

もしもオペランドがブーリアン出ない場合、評価のためにブーリアンに変換されます。

例えば、数値 `1`  は `true` として扱われ、数値 `0` は -- `false` となります:

```js run
if (1 || 0) { // if( true || false ) のように動作します
  alert( 'truthy!' );
}
```

ほとんどの場合で、OR `||` は `if` ステートメントの中で、与えられた条件のいずれかが正しいかを確認するために使われます。

例:

```js run
let hour = 9;

*!*
if (hour < 10 || hour > 18) {
*/!*
  alert( 'The office is closed.' );
}
```

より多くの条件を通すこともできます:

```js run
let hour = 12;
let isWeekend = true;

if (hour < 10 || hour > 18 || isWeekend) {
  alert( 'The office is closed.' ); // 週末です
}
```

## OR は最初の真値を探します [#or-seeks-the-first-truthy-value]

上で描かれたロジックはいくらか古典的です。今、JavaScriptの特別な機能を持ってきましょう。

拡張されたアルゴリズムは次の通りに動作します。

与えられた複数の OR の値:

```js
result = value1 || value2 || value3;
```

OR `"||"` 演算子は次のように動きます:

- 左から右にオペランドを評価します。
- それぞれのオペランドで、それをブーリアンに変換します。もしも結果が `true` であれば、ストップしオペランドの本来の値を返します。
- もしもすべての他のオペランドが評価された場合(i.e. すべて `偽` のとき), 最後のオペランドを返します。

値は、変換されていない、本来の形式で返却されます。

言い換えると、OR `"||"` のチェインは最初に真となる値を返し、そのような値がない場合には最後のオペランドが返却されます。

例:

```js run
alert( 1 || 0 ); // 1 (1 は真)
alert( true || 'no matter what' ); // (true は真)

alert( null || 1 ); // 1 (1 は最初の真値)
alert( null || 0 || 1 ); // 1 (最初の真値)
alert( undefined || null || 0 ); // 0 (すべて偽、なので最後の値が返却される)
```

それは "純粋で古典的な真偽値のみのOR" と比較して、いくつかの興味深い使用方法使用方法につながります。

1. **変数または式のリストから最初の真値を取得する**

    いくつかの変数を持っていると想像してください、それはデータを含むか `null/undefined` になります。そして、私たちは最初のデータを選ぶ必要があります。

    私たちは、そのために OR `||` を使うことができます:

    ```js run
    let currentUser = null;
    let defaultUser = "John";

    *!*
    let name = currentUser || defaultUser || "unnamed";
    */!*

    alert( name ); // "John" – 最初の真値です
    ```

    もしも `currentUser` と `defaultUser` が共に偽の場合、`"unnamed"` が結果になります。
2. **短絡評価**

    オペランドは値だけでなく、任意の式になることができます。OR は左から右にそれらを評価しテストします。
    真値に到達したとき、評価はストップします。そしてその値が返却されます。この処理は、左から右にできるだけ短くなるので、"短絡評価" と呼ばれます。

    これは第2引数が与えられた式が副作用を持つ場合にはっきりとわかります。変数の割り当てと同じです:

    もしも私たちは下の例を実行すると、 `x` は割り当てられません。:

    ```js run no-beautify
    let x;

    *!*true*/!* || (x = 1);

    alert(x); // undefined, なぜなら (x = 1) は評価されないため
    ```

    ...また、もしも1つ目の引数が `false` の場合、 `OR` は次へ行き2つ目の評価をし、代入を実行します:

    ```js run no-beautify
    let x;

    *!*false*/!* || (x = 1);

    alert(x); // 1
    ```

    代入は単純なケースです、他の副作用が関与する可能性があります。

    ご覧のように、このようなユースケースは "`if` をするより短い方法" です。最初のオペランドは真偽値に変換され、もしもそれが偽の場合は2つ目が評価されます。

    ほとんどの場合、コードを理解しやすくするために "正規の" `if` を使う方がよいです。しかしときには便利なこともあります。

## && (AND) [#and]

AND 演算子は2つのアンパサンド `&&` で表されます:

```js
result = a && b;
```

古典的なプログラミングでは、AND は両方のオペランドが真のときに `true` を返します。それ以外の場合は `false` です:

```js run
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
```

`if` の例:

```js run
let hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  alert( 'Time is 12:30' );
}
```

OR のように、AND のオペランドとして任意の値が許可されています:

```js run
if (1 && 0) { // true && false として評価される
  alert( "won't work, because the result is falsy" );
}
```


## AND は最初の偽値を探します [#and-seeks-the-first-falsy-value]

複数のANDされた値が与えられました:

```js
result = value1 && value2 && value3;
```

AND `"&&"` 演算子は次のようにします:

- 左から右にオペランドを評価します。
- それぞれのオペランドで、それをブーリアンに変換します。もしも結果が `false` の場合、ストップし、そのオペランドの本来の値を返します。
- もしもすべての他のオペランドが評価された場合(i.e. すべて `真` のとき), 最後のオペランドを返します。

言い換えると、ANDは最初の偽値、またはない場合は最後の値を返します。

上のルールはORと似ています。違いはANDは最初の *偽値* でORは最初の *真値* です。

例:

```js run
// 最初のオペランドが真の場合、
// AND は2つ目のオペランドを返す:
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5

// 最初のオペランドが偽の場合、
// AND はそれを返します。2つ目のオペランドは無視されます。
alert( null && 5 ); // null
alert( 0 && "no matter what" ); // 0
```

私たちは、続けていくつかの値を渡すこともできます。
どのように最初の偽値が返却されるか見てください。:

```js run
alert( 1 && 2 && null && 3 ); // null
```

すべての値が真のとき、最後の値が返却されます。:

```js run
alert( 1 && 2 && 3 ); // 3, 最後のオペランド
```

````smart header="AND `&&` は OR `||` の前に実行します"
AND `&&` 演算子の優先順位は OR `||` よりも高いです。そのため、ORの前の実行されます。

下のコードでは、`1 && 0` が最初に計算されます:

```js run
alert( 5 || 1 && 0 ); // 5
```
````

ORのように、AND `&&` 演算子は `if` に置き換えることができるときもあります。

例:

```js run
let x = 1;

(x > 0) && alert( 'Greater than zero!' );
```

`&&` の右側のアクションは、その評価に到達した場合にのみ実行されます。つまり: `(x > 0)` が true の場合のみ。

そのため、私たちは基本的にそのための類似を持っています:

```js run
let x = 1;

if (x > 0) {
  alert( 'Greater than zero!' );
}
```

`&&` を含むバリアントは、より短いように見えます。しかし `if` はより明白で、少し読みやすい傾向にあります。

なので、その目的のためにすべての構成要素を使うことを推奨します。もし if が必要なら `if` を使います。AND が必要なら `&&` を使います。

## ! (NOT) [#not]

真偽値否定演算子は感嘆符 `"!"` で表現されます。

構文はとてもシンプルです:

```js
result = !value;
```

演算子は1つの引数を受けいれ、次のようにします:

1. オペランドを真偽値型に変換します: `true/false`。
2. 逆の値を返します。

例:

```js run
alert( !true ); // false
alert( !0 ); // true
```

2つの否定 `!!` は時々値を真偽値型に変換するために使われます:

```js run
alert( !!"non-empty string" ); // true
alert( !!null ); // false
```

つまり、最初の NOT は値を真偽値に変換し、その逆を返します。そして、2つ目の NOT は再びその逆をします。
最後に、私たちは明示的な値からブール値への変換があります。

同じことをするもう少し冗長な方法があります -- 組み込みの `Boolean` 関数です。:

```js run
alert( Boolean("non-empty string") ); // true
alert( Boolean(null) ); // false
```

# 論理演算子

JavaScriptには3つの論理演算子があります:  `||` (OR:論理和), `&&` (AND:論理積), `!` (NOT:否定)

それらは "論理" と呼ばれますが、Boolean 型だけでなく、どの型の値にも適用することができます。結果もまた任意の型になります。

詳細を見てみましょう:

[cut]

## || (OR) 

"OR" 演算子は2つの縦の記号で表現されます:

```js
result = a || b;
```

古典的なプログラミングでは、論理和はブール値のみを操作することを意味していました。もしもその引数のいずれかが `true` の場合、それは `true` を返します。そうでなければ `false` を返します。

JavaScriptでは、演算子は少し難解で強力です。最初にブール値で起こることを見てみましょう。

4つの取りうる論理的な組み合わせがあります:

```js run
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
```

ご覧の通り、両方のオペランドが `false` の場合を除き、結果は常に `true` です。

もしもオペランドが Boolean でない場合、評価のために Boolean に変換されます。

例えば、数値 `1`  は `true` として扱われ、数値 `0` は `false` となります:

```js run
if (1 || 0) { // if( true || false ) のように動作します
  alert( 'truthy!' );
}
```

ほとんどの場合、OR `||` は `if` 文の中で、与えられた条件のいずれかが正しいかを確認するために使われます。

例:

```js run
let hour = 9;

*!*
if (hour < 10 || hour > 18) {
*/!*
  alert( 'The office is closed.' );
}
```

より多くの条件を書くこともできます:

```js run
let hour = 12;
let isWeekend = true;

if (hour < 10 || hour > 18 || isWeekend) {
  alert( 'The office is closed.' ); // 週末です
}
```

## OR は最初の真値を探します 

上で描かれたロジックはいくらか古典的です。ここで JavaScriptの特別な機能を持ってきましょう。

拡張されたアルゴリズムは次の通りに動作します。

与えられた複数の OR の値:

```js
result = value1 || value2 || value3;
```

OR `"||"` 演算子は次のように動きます:

- 左から右にオペランドを評価します。
- それぞれのオペランドで、それを Boolean に変換します。もしも結果が `true` であれば、停止しオペランドの本来の値を返します。
- もしもすべての他のオペランドが評価された場合(i.e. すべて `偽` のとき), 最後のオペランドを返します。

値は変換されていない本来の形式で返却されます。

つまり、OR `"||"` のチェーンは最初に真となる値を返し、そのような値がない場合には最後のオペランドが返却されます。

例:

```js run
alert( 1 || 0 ); // 1 (1 は真)
alert( true || 'no matter what' ); // (true は真)

alert( null || 1 ); // 1 (1 は最初の真値)
alert( null || 0 || 1 ); // 1 (最初の真値)
alert( undefined || null || 0 ); // 0 (すべて偽、なので最後の値が返却される)
```

それは "純粋で古典的な真偽値のみの OR" と比較して、いくつかの興味深い使用方法につながります。

1. **変数または式のリストから最初の真値を取得する**

    いくつかの変数を持っていると想像してください、それはデータを含むか `null/undefined` になります。そして、私たちは最初のデータを選ぶ必要があります。

    そのために OR `||` を使うことができます:

    ```js run
    let currentUser = null;
    let defaultUser = "John";

    *!*
    let name = currentUser || defaultUser || "unnamed";
    */!*

    alert( name ); // "John" – 最初の真値です
    ```

    `currentUser` と `defaultUser` が共に偽の場合、`"unnamed"` が結果になります。
2. **短絡評価**

    オペランドには値だけでなく、任意の式を使用できます。 ORは左から右へ評価してテストします。
    真値に到達したとき、評価はストップします。そしてその値が返却されます。この処理は左から右にできるだけ短くなるので、"短絡評価" と呼ばれます。

    これは第2引数が与えられた式が副作用を持つ場合にはっきりとわかります。変数の割り当てと同じです:

    下の例を実行した場合、`x` は割り当てられません。:

    ```js run no-beautify
    let x;

    *!*true*/!* || (x = 1);

    alert(x); // undefined, なぜなら (x = 1) は評価されないため
    ```

    ...また、1つ目の引数が `false` の場合、 `OR` は次へ行き2つ目の評価を行い、代入をします:

    ```js run no-beautify
    let x;

    *!*false*/!* || (x = 1);

    alert(x); // 1
    ```

    代入は単純なケースであり、他の副作用が発生する可能性があります。

    ご覧のように、このようなユースケースは "`if` をするより短い方法" です。最初のオペランドは真偽値に変換され、もしもそれが偽の場合は2つ目が評価されます。

    ときには便利なこともありますが、多くのの場合コードを理解しやすくするために "正規の" `if` を使う方がよいでしょう。

## && (AND) 

AND 演算子は2つのアンパサンド `&&` で表されます:

```js
result = a && b;
```

古典的なプログラミングでは、AND は両方のオペランドが真のときに `true` を返します。それ以外の場合は `false` です:

```js run
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
```

`if` の例:

```js run
let hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  alert( 'Time is 12:30' );
}
```

OR のように、AND のオペランドとして任意の値が許可されています:

```js run
if (1 && 0) { // true && false として評価される
  alert( "won't work, because the result is falsy" );
}
```


## AND は最初の偽値を探します 

複数のANDされた値が与えられました:

```js
result = value1 && value2 && value3;
```

AND `"&&"` 演算子は次のように動きます:

- 左から右にオペランドを評価します。
- それぞれのオペランドで、それを Boolean に変換します。もしも結果が `false` の場合、ストップしそのオペランドの本来の値を返します。
- もしもすべての他のオペランドが評価された場合(i.e. すべて `真` のとき), 最後のオペランドを返します。

つまり、ANDは最初の偽値、またはない場合には最後の値を返します。

上のルールはORと似ています。違いはANDは最初の *偽値* でORは最初の *真値* です。

例:

```js run
// 最初のオペランドが真の場合、
// AND は2つ目のオペランドを返す:
alert( 1 && 0 ); // 0
alert( 1 && 5 ); // 5

// 最初のオペランドが偽の場合、
// AND はそれを返します。2つ目のオペランドは無視されます。
alert( null && 5 ); // null
alert( 0 && "no matter what" ); // 0
```

より多くの値を渡すこともできます。
どのように最初の偽値が返却されるか見てください。:

```js run
alert( 1 && 2 && null && 3 ); // null
```

すべての値が真のとき、最後の値が返却されます。:

```js run
alert( 1 && 2 && 3 ); // 3, 最後のオペランド
```

````smart header="AND `&&` は OR `||` の前に実行します"
AND `&&` 演算子の優先順位は OR `||` よりも高いです。そのため、ORの前に実行されます。

下のコードでは、`1 && 0` が最初に計算されます:

```js run
alert( 5 || 1 && 0 ); // 5
```
````

ORのように、AND `&&` 演算子は `if` に置き換えることができるときもあります。

例:

```js run
let x = 1;

(x > 0) && alert( 'Greater than zero!' );
```

`&&` の右側のアクションは、その評価に到達した場合にのみ実行されます。つまり: `(x > 0)` が true の場合のみです。

なので、基本的に同じことをする別の方法があります:

```js run
let x = 1;

if (x > 0) {
  alert( 'Greater than zero!' );
}
```

`&&` を含むやり方は、より短いように見えます。しかし `if` はより明白で、より読みやすい傾向にあります。

なので、すべての構成要素を目的に応じて使うことを推奨します。if が必要なら `if` を使います。AND が必要なら `&&` を使います。

## ! (NOT) 

真偽値否定演算子は感嘆符 `"!"` で表現されます。

構文はとてもシンプルです:

```js
result = !value;
```

演算子は1つの引数を取り、次のようにします:

1. オペランドを真偽値型に変換します: `true/false`。
2. 逆の値を返します。

例:

```js run
alert( !true ); // false
alert( !0 ); // true
```

2つの否定 `!!` は値を真偽値型に変換するために使われることがあります:

```js run
alert( !!"non-empty string" ); // true
alert( !!null ); // false
```

つまり、最初の NOT は値を真偽値に変換しその逆を返します。そして、2つ目の NOT は再びその逆をします。最終的に、明示的な値からブール値への変換を行います。

少し冗長ですが同じことをする方法があります -- 組み込みの `Boolean` 関数です。:

```js run
alert( Boolean("non-empty string") ); // true
alert( Boolean(null) ); // false
```

# mocha による自動テスト

さらなるタスクでは、自動化テストが使用されます。

実際、それは開発者の "最低限の教育" の一部です。

[cut]

## なぜテストが必要？

関数を書くとき、通常それがすることをイメージできます: どのパラメータがどの結果となるか。

開発中、私たちは関数を実行し、その結果と期待値を比較することで確認を行うことができます。例えば、コンソール上でそれを行うことができます。

もし何かが間違っていたら -- コードを直し、再度実行し、結果を確認します -- と言ったことを上手く動くまで。

しかしそのような手動の "再実行" は十分ではありません。

**手動の再実行でコードをテストする時、間違えやすい**

例えば、我々は関数 `f` を作っています。いくらかコードを書き、テストします: `f(1)` は動きますが、`f(2)` は動きません。私たちがコードを直すと `f(2)` が動くようになります。これで完璧に見えますか？しかし `f(1)` の再テストを忘れており、それはエラーになるかもしれません。

これは非常に典型的なパターンです。何かを開発するとき、多くのユースケースの可能性を心に留めます。しかし、全ての変更のたびに、手動でそれらすべてをチェックするのをプログラマに期待するのは難しいです。なので、1つを直し別の1つを壊すことが簡単になります。

**自動テストは、コードに加えてテストが別々に書かれていることを意味します。それらは簡単に実行し、全ての主要なユースケースをチェックすることができます。**

## ビヘイビア駆動開発(BDD)

[ビヘイビア駆動開発](http://en.wikipedia.org/wiki/Behavior-driven_development),もしくは BDD と呼ばれるテクニックを使ってみましょう。そのアプローチは多くのプロジェクトの間で使われています。BDDは単なるテストについてのものではありません。それ以上です。

**BDD には3つのことがあります。テスト、ドキュメンテーション、そして例です。**

十分な言葉です。例を見てみましょう。

## "pow" の開発: 仕様

`x` の `n` 乗をする関数 `pow(x, n)` が作りたいとしましょう。`n≥0` と仮定します。

このタスクは単に例です: JavaScriptではそれをするための `**` 演算子がありますが、ここでは、より複雑なタスクに対しても同様に適応することができる開発フローに集中します。

私たちは、`pow` のコードを作成する前に、関数が何をすべきかを想像することができます。

このような記述は *仕様*、もしくはスペックと呼ばれ、このようになります:

```js
describe("pow", function() {

  it("raises to n-th power", function() {
    assert.equal(pow(2, 3), 8);
  });

});
```

上記の通り、仕様は三つの主要な構成要素を持っています:

`describe("title", function() { ... })`
: 何の機能を記述しているか。"worker" -- `it` のブロックのことです、をグループ化するために使います。このケースでは、関数 `pow` について記述しています。

`it("title", function() { ... })`
: `it` のタイトルでは、特定のユースケースを人間が読めるように記述し、２つ目の引数は、それをテストするための関数です。

`assert.equal(value1, value2)`
: `it` ブロックの中のコード、もし実装が正しければエラーなく実行されます。

    関数 `assert.*` は`pow`が期待通り動作するかをチェックするために使われます。ここでは、それらの１つを使っています -- `assert.equal`, それは引数を比較し、等しくない場合にエラーを返します。ここでは `pow(2, 3)` の結果が `8` と等しいかをチェックします。

    他のタイプの比較やチェックもたくさんあります。

## 開発フロー

開発フローは通常このようになります:

1. 最も基本的な機能のテストと一緒に、初期仕様が書かれます。
2. 初期の実装がされます。
3. それが動くかを確認するため、テストフレームワークである [Mocha](http://mochajs.org/) (より詳細はこの後) を実行します。エラーが表示されます。すべてが動作するまで修正を行います。
4. テストと一緒に、動作する初期の実装ができあがります。
5. まだ実装でサポートされていない可能性のある、より多くのユースケースを仕様(テスト)に追加します。テストは失敗し始めます。
6. 3に戻り、テストのエラーが無くなるまで実装を更新します。
7. 機能が準備できる準備できるまで3-6のステップを繰り返します。

従って、開発は *反復* です。仕様を書き、それを実装し、テストが通ることを確認し、さらにテストを書いて、それらが動作することを確認します。最終的に、動作する実装とテストが出来上がります。

私たちのケースでは、最初のステップは完了です: `pow` の初期仕様を持っています。なので、実装しましょう。しかし、その前にテストが動作すること(それ自体はすべて失敗します)を、試してみましょう。

## The spec in action

このチュートリアルでは、テストのために次のJavaScriptライブラリを使います:

- [Mocha](http://mochajs.org/) -- コアフレームワーク: `describe`　や `it` を含む共通のテスト関数と、テストを実行するメインの機能を提供します。
- [Chai](http://chaijs.com) -- 多くのアサーションを持つライブラリ。様々なアサーションを使う事ができます。今は `assert.equal` だけ必要です。
- [Sinon](http://sinonjs.org/) -- 関数をスパイするためのライブラリで、組み込み関数とそれ以上のものをエミュレートします。私たちは、後でこれらを必要とします。

これらのライブラリはブラウザとサーバサイド両方のテストに適しています。ここでは、ブラウザのバリアントについて検討します。

それらのフレームワークと `pow` 仕様の完全なHTMLページ:

```html src="index.html"
```

ページは４つのパートに分かれています:

1. `<head>` -- テストのためのサードパーティーのライブラリやスタイルの追加
2. テストするための関数の `<script>`、このケースでは -- `pow` のためのコード。
3. テスト -- 我々のケースでは、上にあった `describe("pow", ...)` を持つ外部スクリプト `test.js`。
4. Mocha が結果を出力するために、HTML要素 `<div id="mocha">` が使われます。
5. テストはコマンド `mocha.run()` で開始されます。

結果:

[iframe height=250 src="pow-1" border=1 edit]

今のところ、テストは失敗し、エラーがあります。それは論理的です: `pow` のコードは空なので、`pow(2, 3)` は `8` ではなく `undefined` を返します。

将来的には、[karma](https://karma-runner.github.io/) のような高度なテストランナーがあることに留意しましょう。なので、一般的には多くの異なるテストのセットアップは問題にはなりません。

## 初期の実装

テストを通すための、`pow` のシンプルな実装を作りましょう:

```js
function pow() {
  return 8; // :) we cheat!
}
```

おぉ、これでも動作します!

[iframe height=250 src="pow-min" border=1 edit]

## 仕様を改善する

私たちがしたことは、完全にずるです。関数は動作しません: `pow(3, 4)` を計算する試みは正しくない結果を返すでしょう、しかしテストは通ります。

...しかしこの状況は非常に典型的で、実践で起こります。テストは通るが、関数は間違って動作します。私たちの仕様は不完全であり、ユースケースの追加が必要です。

`pow(3, 4) = 81` かどうか確認するためのテストを追加しましょう。

ここでテストを整理するために、２つの方法のうちいずれかを選ぶことができます:

1. 最初のバリアント -- 同じ `it` に `assert` を追加します:

    ```js
    describe("pow", function() {

      it("raises to n-th power", function() {
        assert.equal(pow(2, 3), 8);
    *!*
        assert.equal(pow(3, 4), 81);
    */!*
      });

    });
    ```
2. ２つ目は -- ２つのテストを作ります:

    ```js
    describe("pow", function() {

      it("2 raised to power 3 is 8", function() {
        assert.equal(pow(2, 3), 8);
      });

      it("3 raised to power 3 is 27", function() {
        assert.equal(pow(3, 3), 27);
      });

    });
    ```

主な違いは、`assert` がエラーをトリガするとき、 `it` ブロックは直ちに終了することです。そのため、最初のバリアントにおいて、もしも最初の `assert` が失敗すると、２つ目の `assert` の結果を見ることは決してありません。

テストを分けて作ることは、何が起こっているのかについてより多くの情報を得るのに便利なので、２つ目のバリアントのほうが良いです。

それに加えて、それに従うのが良いもう一つのルールがあります。

**1つのテストは１つのことを確認します。**

もし私たちがテストを見て、２つの独立したチェックがその中にある場合、分割して２つのシンプルなテストにするほうが良いです。

なので、２つ目のバリアントを継続しましょう。

結果:

[iframe height=250 src="pow-2" edit border="1"]

私たちが期待したとおり、２つ目のテストは失敗しました。もちろん、`assert` が `27` を期待する一方で関数は常に `8` を返すので。

## 実装を改善する

テストを通すためにより現実のものを書きましょう:

```js
function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

関数が上手く動作することを確認するために、より多くの値をテストしてみましょう。`it` ブロックを手動で書く代わりに、`for` でそれを生成することができます:

```js
describe("pow", function() {

  function makeTest(x) {
    let expected = x * x * x;
    it(`${x} in the power 3 is ${expected}`, function() {
      assert.equal(pow(x, 3), expected);
    });
  }

  for (let x = 1; x <= 5; x++) {
    makeTest(x);
  }

});
```

結果:

[iframe height=250 src="pow-3" edit border="1"]

## ネストされた記述

私たちはさらにより多くのテストを追加します。しかしその前にヘルパー関数 `makeTest` と `for` が一緒にグループ化されるべきことに注意しましょう。他のテストでは `makeTest` は不要であり、`for` の中でのみ必要とされます: それらの共通のタスクは、与えられた累乗で `pow` がどのようになるかを確認することです。

グルーピングはネストされた `describe` で行われます:

```js
describe("pow", function() {

*!*
  describe("raises x to power n", function() {
*/!*

    function makeTest(x) {
      let expected = x * x * x;
      it(`${x} in the power 3 is ${expected}`, function() {
        assert.equal(pow(x, 3), expected);
      });
    }

    for (let x = 1; x <= 5; x++) {
      makeTest(x);
    }

*!*
  });
*/!*

  // ... more tests to follow here, both describe and it can be added
});
```

ネストされた `describe` はテストの新しい "サブグループ" を定義します。出力では、タイトル付けされたインデントとして見ることが出来ます:

[iframe height=250 src="pow-4" edit border="1"]

将来、自身のヘルパー関数と一緒にトップレベルにより多くの `it` や `describe` を追加することができ、それらに `makeTest` は見えません。

````smart header="`before/after` と `beforeEach/afterEach`"
テストを実行する前後に実行する `before/after` 関数を設定することができ、また *すべての* `it` の前後で実行する `beforeEach/afterEach` もあります。

例:

```js no-beautify
describe("test", function() {

  before(() => alert("Testing started – before all tests"));
  after(() => alert("Testing finished – after all tests"));

  beforeEach(() => alert("Before a test – enter a test"));
  afterEach(() => alert("After a test – exit a test"));

  it('test 1', () => alert(1));
  it('test 2', () => alert(2));

});
```

実行順序はこうなります:

```
Testing started – before all tests (before)
Before a test – enter a test (beforeEach)
1
After a test – exit a test   (afterEach)
Before a test – enter a test (beforeEach)
2
After a test – exit a test   (afterEach)
Testing finished – after all tests (after)
```

[edit src="beforeafter" title="Open the example in the sandbox."]

通常、`beforeEach/afterEach` (`before/each`) は初期化の実行のために使われ、カウンタをゼロにしたり、テストの間で何かをするときに使われます。
````

## 仕様を拡張する

`pow` の基本的な機能は完成です。開発の最初のイテレーションをしました。我々の仕事を祝いシャンパンを飲んだ後は、 -- それを続けて改善しましょう。

言ったように、関数 `pow(x, n)` は正の整数値 `n`を扱うことを意図しています。

数学的なエラーを指し示すために、JavaScript関数は通常 `NaN` を返します。`n` の不正値を同じようにしましょう。

仕様(!)へその振る舞いを追加しましょう。:

```js
describe("pow", function() {

  // ...

  it("for negative n the result is NaN", function() {
*!*
    assert.isNaN(pow(2, -1));
*/!*
  });

  it("for non-integer n the result is NaN", function() {
*!*
    assert.isNaN(pow(2, 1.5));    
*/!*
  });

});
```

新しいテストの結果:

[iframe height=530 src="pow-nan" edit border="1"]

私たちの実装はそれらをサポートしていないので、新たに追加されたテストは失敗します。それが BDD の仕組みです: 最初に失敗するテストを書き、次にそれらのための実装を作ります。

```smart header="他のアサーション"

`assert.isNaN` のアサーションに注目してください: `NaN` のチェックです。

Chaiには他にもアサーションがあります、例えば:

- `assert.equal(value1, value2)` -- 等しいかどうかをチェックします  `value1 == value2`.
- `assert.strictEqual(value1, value2)` -- 厳密な等価チェックをします `value1 === value2`.
- `assert.notEqual`, `assert.notStrictEqual` -- 上と逆のチェックをします。
- `assert.isTrue(value)` -- `value === true` をチェックします。
- `assert.isFalse(value)` -- `value === false` をちぇっくします。
- ...[docs](http://chaijs.com/api/assert/)に完全なリストがあります。

従って、`pow` にいくつかの行を追加します:

```js
function pow(x, n) {
*!*
  if (n < 0) return NaN;
  if (Math.round(n) != n) return NaN;
*/!*

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

これで動作し、全てのテストが通ります:

[iframe height=300 src="pow-full" edit border="1"]

[edit src="pow-full" title="Open the full final example in the sandbox."]

## サマリ [#summary]

BDDでは、仕様が最初で実装はそれに従います。最終的に仕様とコードを持つ事になります。

仕様は３つの方法で使うことが出来ます:

1. **テスト** コードが正しく動作するこをと保証します。
2. **ドキュメント** -- `describe` と `it` のタイトルはその関数がすることを示します。
3. **例** -- テストは実際には、関数がどのように使われるのかを見せる、動作するサンプルです。

仕様があると、安全に改善、変更、スクラッチで関数の書き直しですらもでき、それがまだ正しく動くことを確認することができます。

関数が多くの場所で使われる場合、大規模なプロジェクトではそれが特に重要になります。私たちがこのような関数を変更するとき、それを使う全ての箇所で正しく動作するかを手動で確認する方法はありません。

テストなしだと、人々には２つの方法があります:

1. たとえ何が起ころうと、変更を実行します。そして、我々のユーザはバグを見つけ、それを報告します。
2. もしくは、エラーへの罰が厳しい場合、人々はこのような関数を変更することを恐れるようになります。そしてそれは古くなり、クモの巣でぼうぼうになり、誰もその中に入りたくなくなります。それは良いことではありません。

**自動テストコードはその反対です!**

もしプロジェクトがテストでカバーされていれば、このような問題はありません。私たちはテストを走らせ、あっという間に多くの確認結果を知ることができます。

**さらに、よくテストされたコードは、より良いアーキテクチャを持っています。**

無論、変更や改善が容易だからですが、それだけではありません。

テストを書くためには、すべての関数が明確に記述されたタスク、よく定義された入力と出力を持つようにコードを編成する必要があります。それは最初からよいアーキテクチャであることを意味します。

実際の生活では、それはそう簡単ではありません。どのような挙動をするべきかまだ明確で無い場合、実際のコードの前に仕様を書くのが難しいときもあります。しかし、一般的には、テストを書くことは開発を速く、より安定させます。

## 今度は何？

このチュートリアルの後半では、あなたはより実践的な例を見ることなるでしょう。

テストを記述するためには、良いJavaScriptの知識を必要とします。しかし、私たちはそれを学び始めたばかりです。なので、今のところはすべてを解決するために、テストを書くことは必要とされていません。しかし、このチャプターより少し複雑であっても、あなたはすでにテストを書くことができます。

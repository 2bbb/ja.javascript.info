# プリミティブのメソッド

JavaScriptはプリミティブ(文字列、数値など)をオブジェクトのように扱うことができます。

また、呼び出すメソッドなども提供しています。それらをすぐに学ぶつもりですが、最初にどのように動作するのか確認しましょう。なぜなら、プリミティブはオブジェクトではないからです(ここではさらに明確にしていきます)

[cut]

プリミティブとオブジェクトの主な違いを見ていきましょう。

プリミティブ

オブジェクト
: プロパティとして複数の値を保持することが出来ます。
`{}` で作ることができます。例えば: `{name: "John", age: 30}`。JavaScriptでは他の種類のオブジェクトもあります。関数もオブジェクトです。

オブジェクトの最も良いところの1つは、そのプロパティの1つとして関数を保持することができることです:

```js run
let john = {
  name: "John",
  sayHi: function() {
    alert("Hi buddy!");
  }
};

john.sayHi(); // Hi buddy!
```

従って、ここでは、`sayHi` メソッドをもつ `john` オブジェクトを作りました。

日付、エラー、HTML要素などで動作するような、多くの組み込みのオブジェクトが既に存在します。それらは異なるプロパティとメソッドを持っています。

しかし、それらの機能にはコストがかかります!

オブジェクトはプリミティブよりも "重い" です。内部の仕組みをサポートするための追加のリソースを必要とします。しかし、プロパティやメソッドはプログラミングをする上でとても役立つため、JavaScriptエンジンはそれらの負担を減らすために最適化を試みます。

## オブジェクトとしてのプリミティブ 

JavaScriptの作成者が直面するパラドックスは次のとおりです。:

- 文字列や数字のようなプリミティブでやりたいことがたくさんあります。 メソッドとして実現することは素晴らしいことでしょう。
- プリミティブはできるだけ高速、かつ軽量でなければなりません。

解決方法は少し野暮ですが次の通りです:

1. プリミティブは依然として原始的です。必要に応じて単一の値です。
2. 言語は、文字列、数値、真偽値そしてシンボルのメソッドやプロパティにアクセスすることができます。
3. 必要に応じて、特別な "オブジェクトラッパー" が作られ、拡張機能が提供され、その後破棄されます。

"オブジェクトラッパー" はプリミティブ型毎に異なり、`String`, `Number`, `Boolean`, `Symbol` と呼ばれます。従って、異なるメソッドのセットを提供します。

例えば、大文字化された文字列を返す [str.toUpperCase()](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase) というメソッドがあります。

次のように動作します:

```js run
let str = "Hello";

alert( str.toUpperCase() ); // HELLO
```

シンプルですよね？ `str.toUpperCase()` で実際に何が起こっているのでしょう:

1. 文字列 `str` はプリミティブです。なので、プロパティへアクセスした瞬間に、文字列の値を知る特別なオブジェクトが作られ、それは `toUpperCase()` のような便利なメソッドを持ちます。
2. メソッドは実行し新たな文字列を返します(`alert` で表示されたものです)
3. 特別なオブジェクトは破棄され、プリミティブの `str` だけが残ります。

従って、プリミティブはメソッドを提供できますが、それらは以前として軽量なままです。

JavaScriptエンジンはこの処理を高度に最適化します。余分なオブジェクの作成を完全にスキップするかもしれません。しかし、それは依然として仕様に準拠していなければならず、あたかもオブジェクトを作成したかのように動作しなければなっりません。

数値はそれ自身のメソッドを持っています。例えば、指定された精度に数値を丸める [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) です:

```js run
let n = 1.23456;

alert( n.toFixed(2) ); // 1.23
```

チャプター <info:number> と <info:string> でより具体的なメソッドを見ましょう。


````warn header="コンストラクタ `String/Number/Boolean` は内部でのみ利用します"
Javaなどの言語は `new Number(1)` または `new Boolean(false)` のような構文を使うことで明示的にプリミティブのための "ラッパーオブジェクト" を作ることが出来ます。

JavaScriptにおいても、歴史的な理由から可能ですが、強く *推奨しません*。いくつかの場所で物事がクレイジーになっていくでしょう。

例:

```js run
alert( typeof 1 ); // "number"

alert( typeof new Number(1) ); // "object"!
```

続いて、`zero` がオブジェクトなので、alert が実行されます:

```js run
let zero = new Number(0);

if (zero) { // zero は true, オブジェクトだからです
  alert( "zero is truthy?!?" );
}
```

一方、`new` をつけずに同じ関数 `String/Number/Boolean` を使うことは、全く普通で有用なことです。それらは値を対応する型へ変換します: 文字列、数値、もしくあ真偽値(プリミティブ)

例えば、これは全く妥当です:
```js
let num = Number("123"); // string から number へ変換
```
````


````warn header="null/undefined はメソッドを持ちません"
特別なプリミティブ `null` と `undefined` は例外です。それらは対応する "ラッパーオブジェクト" を持たずメソッドを提供しません。ある意味では "最もプリミティブ" です。

このような値のプロパティへのアクセスはエラーになります:

```js run
alert(null.test); // error
````

## サマリ 

- プリミティブは、`null` と `undefined` の例外を除いて、多くの役立つメソッドを提供します。我々は次のチャプターで学びます。
- 形式的には、それらのメソッドは一時的なオブジェクトを通して行われます。しかしJavaScriptエンジンは内部的に最適化するようチューニングされているため、呼び出しのコストはかかりません。

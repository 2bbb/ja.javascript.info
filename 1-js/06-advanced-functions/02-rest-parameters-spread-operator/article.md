# 残りのパラメータとスプレッド演算子

主なJavaScriptの組み込み関数は任意の数の引数をサポートしています。

例:

- `Math.max(arg1, arg2, ..., argN)` -- 引数の中で最大のものを返します。
- `Object.assign(dest, src1, ..., srcN)` -- `src1..N` のプロパティを `dest` にコピーします。
- ...など.

このチャプターでは、同じようにする方法を説明します。また、より重要なのは、このような関数や配列を快適に扱う方法です。

[cut]

## 残りのパラメータ '...'  

関数は、どのように定義されたかに関係なく、任意の数の引数で呼ぶことができます。

このような感じです:
```js run
function sum(a, b) {
  return a + b;
}

alert( sum(1, 2, 3, 4, 5) );
```

"必要以上の" 引数でエラーにはなりません。 しかし、もちろん結果は最初の2つだけが使われます。

残りのパラメータは、関数定義の中で3つのドット `...` で言及することができます。これは文字通り、"残りのパラメータを配列に集める" という意味です。

例えば、すべての引数を配列 `args` に集める場合は次のようになります:

```js run
function sumAll(...args) { // args は配列の名前です
  let sum = 0;

  for (let arg of args) sum += arg;

  return sum;
}

alert( sumAll(1) ); // 1
alert( sumAll(1, 2) ); // 3
alert( sumAll(1, 2, 3) ); // 6
```

最初のパラメータを変数として取得するようにし、残りだけを集めることもできます。

ここでは、最初の2つの引数が変数に入り、残りは `titles` 配列に格納されます:

```js run
function showName(firstName, lastName, ...titles) {
  alert( firstName + ' ' + lastName ); // Julius Caesar

  // 残りは titles 配列に入ります
  // i.e. titles = ["Consul", "Imperator"]
  alert( titles[0] ); // Consul
  alert( titles[1] ); // Imperator
  alert( titles.length ); // 2
}

showName("Julius", "Caesar", "Consul", "Imperator");
```

````warn header="残りのパラメータは最後である必要があります"
残りのパラメータはすべての残っている引数を集めるため、次は意味がありません:

```js
function f(arg1, ...rest, arg2) { // arg2 after ...rest ?!
  // error
}
```

`...rest` は常に最後です。
````

## "arguments" 変数

インデックスによってすべての引数を含む `arguments` と言う特別な配列のようなオブジェクトもあります。

例:

```js run
function showName() {
  alert( arguments.length );
  alert( arguments[0] );
  alert( arguments[1] );

  // iterable です。
  // for(let arg of arguments) alert(arg);
}

// 表示: 2, Julius, Caesar
showName("Julius", "Caesar");

// 表示: 1, Ilya, undefined (2つ目の引数がないので)
showName("Ilya");
```

昔は、残りのパラメータは言語に存在せず、`arguments` は引数の数に関係なく、関数のすべての引数を取得するための唯一の方法でした。

そして、これはまだ動作するので使うことができます。

が、デメリットは `arguments` は配列ではなく、配列ライクで反復可能という点です。従って、配列メソッドをサポートしないので、 `arguments.map(...)` 呼び出しをすることは出来ません。

また、すべての引数が常に含まれているため、残りのパラメータと同様に部分的に取り込むことはできません。

したがって、これらの機能が必要な場合は、"残りのパラメータ" が好ましいです。

````smart header="アロー関数は `\"arguments\"` を持ちません"
もしもアロー関数から `arguments` オブジェクトにアクセスすると、外部の "通常の" 関数からそれらを取得します。

ここではその例です:

```js run
function f() {
  let showArg = () => alert(arguments[0]);
  showArg();
}

f(1); // 1
```

私たちが覚えているように、アロー関数は自身の `this` を持ちません。今度は特別な `arguments` オブジェクトも持っていないことが分かりました。
````

## スプレッド 演算子 

先ほど、パラメータのリストから配列を取得する方法をみました。

一方、我々はその逆を正確にする必要がある場合があります。

例えば、リストから最大値を返す組み込み関数 [Math.max](mdn:js/Math/max) です。

```js run
alert( Math.max(3, 5, 1) ); // 5
```

今、配列 `[3 ,5, 1]` を持っているとします。それを使って `Math.max` を呼び出す方法はどうやるでしょう？

それを "そのまま" 渡すと上手く動きません。なぜなら `Math.max` は数値引数のリストを期待しており、1つの配列がくることは期待していません。:

```js run
let arr = [3, 5, 1];

*!*
alert( Math.max(arr) ); // NaN
*/!*
```

...そして、きっとコードの中で手動で項目をリストすることも出来ません(`Math.max(arg[0], arg[1], arg[2])`)。なぜならそれがどれだけあるか分からないからです。スクリプトが動くとき、もっと多いかもしれないし、全くないかもしれません。また、その書き方は格好悪いです。

*スプレッド演算子 (Spread operator)* はそれを助けます。残りのパラメータと似ており、`...` を使いますが、全く反対のことをします。

関数呼び出しで `...arr` が使われるとき、反復可能なオブジェクト `arr` を引数のリストに展開します。

`Math.max` の場合:

```js run
let arr = [3, 5, 1];

alert( Math.max(...arr) ); // 5 (配列を引数のリストに変換する)
```

また、この方法で複数の iterables を渡すこともできます:

```js run
let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

alert( Math.max(...arr1, ...arr2) ); // 8
```

...そして、通常の値とスプレッド演算子を組み合わせることもできます。:

```js run
let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

alert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25
```

さらにスプレッド演算子は配列をマージするために使うこともできます:

```js run
let arr = [3, 5, 1];
let arr2 = [8, 9, 15];

*!*
let merged = [0, ...arr, 2, ...arr2];
*/!*

alert(merged); // 0,3,5,1,2,8,9,15 (0, then arr, then 2, then arr2)
```

上の例では、スプレッド演算子の実演をするために配列を使いましたが、任意の iterable で動作します。

例えば、ここではスプレッド演算子を使って、文字列を文字の配列にします:

```js run
let str = "Hello";

alert( [...str] ); // H,e,l,l,o
```

スプレッド演算子は内部的にイテレータを使用して要素を集めます。これは `for..of` と同じ方法です。

従って、文字列では `for..of` は文字を返すので `...str` は `"H","e","l","l","o"` になります。文字のリストは配列初期化子 `[...str]` に渡されます。

この特定のタスクでは、`Array.from` を使うこともできます。それは iterable(文字列のようなもの) を配列に変換するからです:

```js run
let str = "Hello";

// Array.from は iterable を配列に変換します
alert( Array.from(str) ); // H,e,l,l,o
```

結果は `[...str]` と同じです。

しかし `Array.from(obj)` と `[...obj]` には微妙な違いがあります:

- `Array.from`は配列ライクと iterables の両方で動作します。
- スプレッド演算子は iterables でのみ動作します。

従って、何かを配列に変換するタスクにおいては、`Array.from` がより普遍的です。


## サマリ 

コード上で `"..."` を見るとき、それは残りのパラメータかスプレッド演算子です。

それらを区別する簡単な方法があります:

- `...` が関数パラメータの最後にある場合、それは "残りのパラメータ" で、リストの残りを配列に集めます。
- 関数呼び出しなどで `...` があると、それは "スプレッド演算子" と呼ばれ、配列をリストに展開します。

利用パターン:

- 残りのパラメータは、任意の数の引数を受け入れる関数を作成するために使用されます。
- スプレッド演算子は、多くの引数のリストを通常必要とする関数に配列を渡すために使用されます。

共にそれらはリストとパラメータの配列を簡単に移動するのに役立ちます。

関数呼び出しのすべての引数は "昔のスタイル" `arguments`(配列ライクな反復可能オブジェクト) も利用可能です。

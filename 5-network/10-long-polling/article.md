# ロングポーリング

ロングポーリング(Long polling)はサーバと永続的な接続を持つための最も簡単な方法で、WebSocket や Server Side Events などの特定のプロトコルを使いません。

実装はとても簡単であり、多くのケースもこれで十分です。

## 定期的なポーリング

サーバから新しい情報を取得するための最も簡単な方法は、ポーリングです。

つまり、サーバへの定期的なリクエストです: "こんにちは、私はここにいます。私に関してなにか新しい情報はありますか？"。例えば、10秒毎に。

応答では、サーバは最初にクライアントがオンラインであること自身に知らせて、次にその時までに受け取ったメッセージのパケットを送信します。

これは機能しますが、デメリットもあります。:
1. メッセージは最大10秒(リクエスト間隔)の遅延が発生します
2. たとえメッセージがない場合でも、サーバは10秒ごとにリクエストを受け取ります。パフォーマンス観点から見えると、これはバックエンドの処理にかなりの負荷がかかります。

そのため、非常に小さいサービスに関して話す場合にはこのアプローチは現実的ですが、一般的には改善が必要です。

## ロングポーリング

いわゆる "ロングポーリング" はサーバにポーリングするための、はるかに優れた方法です。

これも実装はとても簡単で、遅延なしでメッセージを配信します。

フローです:

1. リクエストがサーバに送信されます。
2. サーバはメッセージがあるまで接続を閉じません。
3. メッセージが現れたら、サーバはそのデータでリクエストに応答します。
4. ブラウザはすぐに新しいリクエストを作ります。

ブラウザがリクエストを送信し、サーバとの接続を保留にしている状況は、このメソッドの普通の状態です。メッセージが配信されたときだけ、接続が再確立されます。

![](long-polling.svg)

もしもネットワークエラーなどで接続が失われた場合は、ブラウザはすぐに新しいリクエストを送信します。

長いリクエストを行う、クライアント側の `subscribe` 関数の概要です。:

```js
async function subscribe() {
  let response = await fetch("/subscribe");

  if (response.status == 502) {
    // 接続タイムアウトエラー
    // 接続が長時間保留されていて、リモートサーバやプロキシがそれを閉じたときに発生する場合があります
    // 再接続しましょう
    await subscribe();
  } else if (response.status != 200) {
    // エラーを表示
    showMessage(response.statusText);
    // 1秒後に再接続します
    await new Promise(resolve => setTimeout(resolve, 1000));
    await subscribe();
  } else {
    // メッセージを取得しました
    let message = await response.text();
    showMessage(message);
    await subscribe();
  }
}

subscribe();
```

ご覧の通り、`subscribe` 関数は fetch を生成し、応答を待ってから処理を行い、その後再び自身を呼び出します。

```warn header="サーバは多数の保留中の接続でもOKである必要があります"
サーバのアーキテクチャは、多数の保留中の接続があっても問題なく動作できるようにする必要があります。

特定のサーバアーキテクチャは、接続毎にプロセスを実行します。多数の接続がある場合、プロセスも多数になり、各プロセスが大量のメモリを消費します。

これは、しばしばバックエンドが PHP, Ruby で書かれたバックエンドの場合ですが、技術的には言語ではなく実装の問題です。

Node.js で書かれたバックエンドには、通常このような問題は起こりません。
```

## デモ: チャット

デモです:

[codetabs src="longpoll" height=500]

## Area of usage

ロングポーリングはメッセージがあまり来ないような状況で上手く機能します。

もしメッセージが非常に頻繁にくる場合、メッセージの送受信の図は上で描かれたような、のこぎりのようになります。

すべてのメッセージは個別のリクエストであり、それぞれがヘッダや認証のオーバヘッドなどを持ちます。

そのため、この場合は、[Websocket](info:websocket) や [Server Sent Events](info:server-sent-events) のような別の方法が推奨されています。

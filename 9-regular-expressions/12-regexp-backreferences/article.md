# 後方参照: \N と \k<name>

キャプチャグループ `pattern:(...)` の中身は、結果や置換文字列の中だけでなくパターン自身の中でも利用することができます。

## 番号による後方参照: \N

グループはパターンの中で `pattern:\N` を使うことで参照することができ、`N` はグループの番号です。

より明白にするために、次のことを考えてみましょう。

私たちは引用符で囲まれた文字列を見つける必要があります: シングルクォート `subject:'...'` もしくはダブルクォート `subject:"..."` -- 両方のバリアントにマッチする必要があります。

どうやってそれらを探しますか？

パターン中に2種類の引用符をおきます: `pattern:['"](.*?)['"]`。これは `match:"..."` と `match:'...'` のような文字列を見つけますが、`subject:"She's the one!"` の文字列のように、ある引用符が別の引用符の中に登場した時、正しくないマッチになります。:

```js run
let str = "He said: \"She's the one!\".";

let reg = /['"](.*?)['"]/g;

// 結果は期待したものではありません
alert( str.match(reg) ); // "She'
```

ご覧の通り、パターンは開始の引用符 `match:"` を見つけ、その後テキストは他の引用符 `match:'` まで進み、マッチを閉じます。

パターンが開始引用符と同じ閉じ引用符を探すようにするために、それをキャプチャグループでラップし、後方参照を使用しましょう `pattern:(['"])(.*?)\1`:

これは正しいコードです:

```js run
let str = "He said: \"She's the one!\".";

let reg = /(['"])(.*?)\1/g;

alert( str.match(reg) ); // "She's the one!"
```

これでうまく動作します! 正規表現エンジンは最初の引用符 `pattern:(['"])` を見つけその中身を覚えます。それは最初のキャプチャグループです。

さらにパターン `pattern:\1` は "最初のグループと同じテキストを見つける" ことを意味します。

同様に、`pattern:\2` は2番目のグループを意味し、`pattern:\3` は3番目…となります。

```smart
グループの中で `?:` を使用している場合は参照することはできません。キャプチャを除外されたグループ `(?:...)` はエンジンに記憶されません。
```

```warn header="混乱しないでください: パターンでの `pattern:\1`, 置換での: `pattern:$1`"
置換文字列では、ドル記号 `pattern:$1` を使用する一方、パターンではバックスラッシュ `pattern:\1` です。
```

## 名前による後方参照: `\k<name>`

正規表現に多くの括弧がある場合、名前付けをすると便利です。

名前付けされたグループを参照するには、`pattern:\k<name>` を使用します。

下記の例では、引用符を持つグループが `pattern:?<quote>` を名前付けされています。なので、後方参照は `pattern:\k<quote>` になります。:

```js run
let str = `He said: "She's the one!".`;

*!*
let regexp = /(?<quote>['"])(.*?)\k<quote>/g;
*/!*

alert( str.match(regexp) ); // "She's the one!"
```